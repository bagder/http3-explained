# 标准化进展情况

QUIC 工作组自 2016 年底以来在积极标准化该协议，现计划于 2019 年 7 月之前完成。

到 2018 年 11 月为止，还没有过大型的 HTTP/3 互通性测试。目前来说，只有 2 个实现进行过测试，且这两个实现不基于浏览器和主流的开源服务器软件。

QUIC 工作组的 wiki 页面目前列出了大约 15 种 QUIC 实现（[QUIC 实现列表](https://github.com/curl/curl/wiki/QUIC-implementation)），但距离它们都能与最新版的规范草案互操作仍有很长的路。

实现 QUIC 并不容易，且到目前为止，协议本身还在不断演变。

## 服务器

Apache 和 Nginx 还没有对 QUIC 支持的公开声明。

## 客户端

还没有任何主流浏览器的任何状态的任何版本支持 IETF 版本的 QUIC 或者 HTTP/3 协议。

Google Chrome 在数年前已经支持 Google 版的 QUIC，但是该版本不能与官方的 QUIC 版本互操作，且它的 HTTP 实现与 HTTP/3 不同。

## 实现的障碍

为了避免重复发明轮子，以及依靠可信赖的现有协议，QUIC 决定使用 TLS 1.3 作为它的加密和安全协议层。不过工作组决定大幅精简 QUIC 中 TLS 的使用，只使用“TLS 信息”（TLS Messages）而不是协议中的“TLS 记录”（TLS Records）。

这听上去可能人畜无害，但也事实上成为了很多 QUIC 堆栈实现者的重大障碍。现存的支持 TLS 1.3 的 TLS 库都没有提供此功能的 API 并允许 QUIC 访问它。有一些 QUIC 的实现由大型机构完成，这些机构可能有自己的 TLS 协议栈，但并不是所有实现都能如此。

例如，主流的重量级开源软件 OpenSSL 就没有这些 API，且到目前（2018 年 11 月）为止，没有表达过在任何时间点提供这些 API 的意愿。

这最终将成为 QUIC 协议栈部署的障碍。因为 QUIC 要么基于其他 TLS 库，要么使用补丁版 OpenSSL 或者等待 OpenSSL 版本更新。

## 操作系统内核、CPU 负载

据 Google 和 Facebook 称，与基于 TLS 的 HTTP/2 相比，它们大规模部署的 QUIC 需要近 2 倍的 CPU 使用量。

对此的进一步解释包括：

- Linux 内核的 UDP 部分没有得到像 TCP 堆栈那样的优化，因为传统上没有使用 UDP 进行如此高速的信息传输。

- TCP 和 TLS 有硬件加速（负载卸载到硬件，offload），而这对于 UDP 很罕见，对于 QUIC 则基本不存在。

就上述理由，我们可以相信 QUIC 的 CPU 使用量能随着时间的推移得到改善。
