# Статус
Рабочая группа QUIC с конца 2016-го года усердно работала над уточнением протоколов
и на момент написания статьи (июнь 2020 года) приближается к завершающей стадии.

В течение 2019-го и 2020-го годов увеличилось число
[тестов на совместимость с HTTP/3](https://docs.google.com/spreadsheets/d/1D0tW89vOoaScs3IY9RGC0UesWGAwE6xyLk0l4JtvTVg),
а также CDN и браузеры начали запускать первоначальную поддержку — хотя часто с использованием флагов.

Существует несколько различных [реализаций QUIC](https://github.com/quick/base-drafts/wiki/Implementations)
на wiki-странице рабочей группы.

Внедрять QUIC непросто, и протокол продолжает развиваться и изменяться даже до настоящего времени.


## Серверы
Поддержка NGINX для QUIC и HTTP/3 находится в стадии разработки, и была анонсирована только
[предварительная версия](https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3).

В то же время заявлений от Apache о поддержке QUIC ещё не было.


## Клиенты
Ни один из крупных поставщиков браузеров еще не выпустил ни одной версии в любом состоянии,
которая могла бы запускать IETF-версию QUIC или HTTP/3.

Google Chrome поставляется с рабочей реализацией собственной реализации QUIC
уже много лет и недавно начала поддерживать версию IETF под флагом. Firefox
аналогичным образом поддерживает это с помощью флага.

сURL предоставил первую экспериментальную поддержку HTTP/3 (draft-22) в релизной версии 7.66.0
от 11-го сентября 2019-го года. cURL использует библиотеки Quiche от Cloudflare и семейство
библиотек ngtcp2.


## Препятствия реализации
Для QUIC решили использовать TLS 1.3 в качестве основы для слоя криптографии и безопасности,
чтобы не изобретать что-то новое и вместо этого полагаться на надежный и существующий протокол.
Однако, делая это, рабочая группа также решила, что для того, чтобы действительно упростить
использование TLS в QUIC, для протокола следует использовать только «сообщения TLS», а не «записи TLS».

Это может показаться безобидным изменением, но на самом деле это создало значительное препятствие
для многих разработчиков стека QUIC. Существующие библиотеки TLS, поддерживающие TLS 1.3, просто
не имеют достаточного API, чтобы предоставить эту функциональность и позволить QUIC получить доступ.
Хотя несколько разработчиков QUIC работают в крупных организациях, которые параллельно работают
над своим собственным стеком TLS, это относится не ко всем.

Доминирующий тяжеловес OpenSSL с открытым исходным кодом, например, не имеет никаких
API для этого. План решения этой проблемы, по-видимому, содержится в их
[PR 8797](https://github.com/openssl/openssl/pull/8797), целью которого является внедрение
API, очень похожего на API BoringSSL.


## Ядра и загрузка процессора
Обе компании, Google и Facebook, упомянули, что для их широкомасштабного развертывания
QUIC требуется примерно в два раза больше ресурсов процессора, чем при той же нагрузке
на трафик при обслуживании HTTP/2 по протоколу TLS.

Некоторыми объяснения этому могут являться:

- В основном порты UDP в Linux вовсе не так оптимизированы, как стек TCP, 
  поскольку традиционно они не использовались для высокоскоростных передач.

- Выгрузка TCP и TLS на аппаратное обеспечение существует, но гораздо
  реже встречается для UDP и практически отсутствует для QUIC.

Есть основания полагать, что производительность и требования к процессору
со временем улучшатся.
